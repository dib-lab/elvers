from os.path import join

prog = "pear"

logs_dir  = config['elvers_directories']['logs']
elvers_params = config[prog]['elvers_params']
prog_params = config[prog]['program_params']

# set output dir
output_dir = elvers_params['outputs']['outdir']
# set default input dir, extensions
input_dir = config['elvers_directories']['outdirs']['preprocess']
ext = '.trim.fq.gz'
# get input we're using in this case
input_name = prog_params.get('inputs', ['trimmed'])[0]
# update input_dir, ext
input_dir = elvers_params['input_options'][input_name].get('indir', input_dir )
ext = elvers_params['input_options'][input_name]['extensions']['read'].get('common_ext', ext)

def get_pairs(w):
    readsD = {}
    if not is_single_end(**w): # note, this requires unit to be in outputs!
        readsD['r1'] = join(input_dir, f'{w.sample}_{w.unit}_1{ext}')
        readsD['r2'] = join(input_dir, f'{w.sample}_{w.unit}_2{ext}')
        return readsD
    return readsD

rule pear_read_merging:
    """
    Merge PE reads with PEAR, for input into PALADIN
	"""
    input:
        unpack(get_pairs)
    output: 
        assembled = join(output_dir, '{sample}_{unit}.pear_assembled.fq.gz'),
        discarded = join(output_dir, '{sample}_{unit}.pear_discarded.fq.gz'),
        unassembled_r1 = join(output_dir, '{sample}_{unit}.pear_unassembled_r1.fq.gz'),
        unassembled_r2 = join(output_dir, '{sample}_{unit}.pear_unassembled_r2.fq.gz'),
    message:
        """--- Merging paired reads using PEAR  ---"""
    params:
        pval = prog_params.get('pval',"0.01"),
        max_memory = prog_params.get('max_memory', "4G"),
        extra = prog_params.get('extra', '')
    threads: 6
    log: join(logs_dir, 'pear/{sample}_{unit}.log')
    benchmark: join(logs_dir, 'pear/{sample}_{unit}.benchmark')
    conda: 'environment.yml'
    script: 'pear-wrapper.py'
