from os.path import join

logs_dir  = config['elvers_directories']['logs']
trinity_elvers_params = config['trinity']['elvers_params']
trinity_prog_params = config['trinity']['program_params']

assembly_dir = trinity_elvers_params['outputs']['outdir']
trinity_assembly_extension = trinity_elvers_params['outputs']['fasta']['extensions']['reference_extensions'][0] # should only be a single entry here, default: '_trinity'

# set default input dir, extensions
#input_dir = config['elvers_directories']['outdirs']['preprocess']
#ext = ['.trim.fq.gz']
# get input we're using in this case
trinity_input_name = trinity_prog_params.get('inputs', ['kmer_trimmed'])[0]
# update input_dir, ext
trinity_input_dir = trinity_elvers_params['input_options'][trinity_input_name].get('indir')
trinity_ext = trinity_elvers_params['input_options'][trinity_input_name]['extensions']['read'].get('common_ext')[0]
BASE = config['basename']

# handle "associated_samples"
associated_samples = {}
if 'assembly_info' in config.keys():
    assemb_info = config['assembly_info']

#in #config['get_reference']['program_params']['reference_list'].items():#config['reference_info'].items()

for ref_ext, ref_info in assemb_info.items(): 
    if trinity_assembly_extension in ref_ext:
        if ref_info.get('associated_samples'):
            sample_list = ref_info['associated_samples']
            if not ref_ext.startswith('_'):
                ref_ext = '_' + ref_ext
            refname = BASE + ref_ext
            associated_samples[refname] = sample_list


def get_assembly_input(w):
    r1,r2,single =[],[],[]
    readsD = {}
#    assembly_subset = prog_params.get('assembly_subset')
    if w.assembly in associated_samples.keys():
        # this assembly has some associated samples
        assembly_subset = associated_samples[w.assembly]
    else: # assume we want to use all samples for this assembly
        assembly_subset = samples['sample'].tolist()
    
    for s, u in samples.iterrows():
        sample, unit = u['sample'],u['unit']
        if assembly_subset:
            if sample not in assembly_subset:
                continue
        if is_single_end(sample, unit):
            single+=[join(trinity_input_dir, f"{sample}_{unit}_se{trinity_ext}")]
        else:
            r1+= [join(trinity_input_dir, f"{sample}_{unit}_1{trinity_ext}")]
            r2+= [join(trinity_input_dir, f"{sample}_{unit}_2{trinity_ext}")]
    add_single = trinity_prog_params.get('add_single_to_paired', False)
    if len(r1) > 0:
        if add_single == True:
            r1 = r1 + single
        readsD['left'] = r1
        readsD['right'] = r2
    else:
        if len(single) > 0:
            readsD['left'] = single
        else:
           sys.stderr.write("\t No samples to assemble. If subsetting, please check that the values of `assembly_subset` match your sample names. See https://dib-lab.github.io/elvers/trinity for details.\n") 
           sys.exit(-1)
    return readsD

rule trinity:
    input:
        unpack(get_assembly_input)
    output:
        #fasta = join(assembly_dir,"trinity_out_dir/Trinity.fasta"),
        #gene_trans_map = join(assembly_dir,"trinity_out_dir/Trinity.fasta.gene_trans_map"),
        fasta = join(assembly_dir, '{assembly}.fasta'),
        gene_trans_map =  join(assembly_dir, '{assembly}.fasta.gene_trans_map')
    message:
        """--- Assembling read data with Trinity --- """
    params:
        # optional parameters
        max_memory=trinity_prog_params.get('max_memory', '10G'),
        seqtype=trinity_prog_params.get('seqtype', 'fq'),
        extra=trinity_prog_params.get('extra', '')
    wildcard_constraints:
        assembly="\S*_trinity"
    threads: 4
    log: join(logs_dir, 'trinity', '{assembly}.log')
    benchmark: join(logs_dir, 'trinity', '{assembly}.benchmark')
    conda: "environment.yml"
	  script: "trinity-wrapper.py"